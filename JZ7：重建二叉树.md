  给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。
![image](https://user-images.githubusercontent.com/47242566/155440912-ba81ba24-65cc-4ac6-8fb5-08f8e531bc10.png)
  提示： 
  1.vin.length =pre.length 
  2.pre和vin均无重复元素 
  3.vin出现的元素均出现在pre里 
  4.只需要返回根结点，系统会自动输出整颗树做答案对比 
  数据范围：n≤2000，节点的值-10000≤val≤10000 
  要求：空间复杂度O(n),时间复杂度O(n) 
  （1）个人思考
  测试案例：无节点，单节点。
  做不出来……
  （2）书中解答
  ①二叉树节点定义：
```C++
struct BinaryTreeNode{
  int m_nValue;
  BinaryTreeNode* m_pLeft;
  BinaryTreeNode* m_pRight;
};
```
  ②使用递归方法求解
  二叉树前序遍历中，第一个数字总是树的根节点的值。而中序遍历中，根节点的值在序列中间，左子树的节点的值位于根节点的值的左边，而右子树的节点的值位于根节点的值的右边。需要扫描中序遍历，才能找到根节点的值。
  如上图所示，前序遍历


